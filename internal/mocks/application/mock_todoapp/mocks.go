// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock_todoapp

import (
	"context"

	"github.com/iktakahiro/oniongo/internal/application/todoapp"
	"github.com/iktakahiro/oniongo/internal/domain/todo"
	mock "github.com/stretchr/testify/mock"
)

// NewMockCompleteTodoUseCase creates a new instance of MockCompleteTodoUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCompleteTodoUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCompleteTodoUseCase {
	mock := &MockCompleteTodoUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCompleteTodoUseCase is an autogenerated mock type for the CompleteTodoUseCase type
type MockCompleteTodoUseCase struct {
	mock.Mock
}

type MockCompleteTodoUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCompleteTodoUseCase) EXPECT() *MockCompleteTodoUseCase_Expecter {
	return &MockCompleteTodoUseCase_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockCompleteTodoUseCase
func (_mock *MockCompleteTodoUseCase) Execute(ctx context.Context, req todoapp.CompleteTodoRequest) error {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.CompleteTodoRequest) error); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCompleteTodoUseCase_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockCompleteTodoUseCase_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockCompleteTodoUseCase_Expecter) Execute(ctx interface{}, req interface{}) *MockCompleteTodoUseCase_Execute_Call {
	return &MockCompleteTodoUseCase_Execute_Call{Call: _e.mock.On("Execute", ctx, req)}
}

func (_c *MockCompleteTodoUseCase_Execute_Call) Run(run func(ctx context.Context, req todoapp.CompleteTodoRequest)) *MockCompleteTodoUseCase_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(todoapp.CompleteTodoRequest))
	})
	return _c
}

func (_c *MockCompleteTodoUseCase_Execute_Call) Return(err error) *MockCompleteTodoUseCase_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCompleteTodoUseCase_Execute_Call) RunAndReturn(run func(ctx context.Context, req todoapp.CompleteTodoRequest) error) *MockCompleteTodoUseCase_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCreateTodoUseCase creates a new instance of MockCreateTodoUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCreateTodoUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCreateTodoUseCase {
	mock := &MockCreateTodoUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCreateTodoUseCase is an autogenerated mock type for the CreateTodoUseCase type
type MockCreateTodoUseCase struct {
	mock.Mock
}

type MockCreateTodoUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCreateTodoUseCase) EXPECT() *MockCreateTodoUseCase_Expecter {
	return &MockCreateTodoUseCase_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockCreateTodoUseCase
func (_mock *MockCreateTodoUseCase) Execute(ctx context.Context, req todoapp.CreateTodoRequest) error {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.CreateTodoRequest) error); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCreateTodoUseCase_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockCreateTodoUseCase_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockCreateTodoUseCase_Expecter) Execute(ctx interface{}, req interface{}) *MockCreateTodoUseCase_Execute_Call {
	return &MockCreateTodoUseCase_Execute_Call{Call: _e.mock.On("Execute", ctx, req)}
}

func (_c *MockCreateTodoUseCase_Execute_Call) Run(run func(ctx context.Context, req todoapp.CreateTodoRequest)) *MockCreateTodoUseCase_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(todoapp.CreateTodoRequest))
	})
	return _c
}

func (_c *MockCreateTodoUseCase_Execute_Call) Return(err error) *MockCreateTodoUseCase_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCreateTodoUseCase_Execute_Call) RunAndReturn(run func(ctx context.Context, req todoapp.CreateTodoRequest) error) *MockCreateTodoUseCase_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDeleteTodoUseCase creates a new instance of MockDeleteTodoUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDeleteTodoUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDeleteTodoUseCase {
	mock := &MockDeleteTodoUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockDeleteTodoUseCase is an autogenerated mock type for the DeleteTodoUseCase type
type MockDeleteTodoUseCase struct {
	mock.Mock
}

type MockDeleteTodoUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDeleteTodoUseCase) EXPECT() *MockDeleteTodoUseCase_Expecter {
	return &MockDeleteTodoUseCase_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockDeleteTodoUseCase
func (_mock *MockDeleteTodoUseCase) Execute(ctx context.Context, req todoapp.DeleteTodoRequest) error {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.DeleteTodoRequest) error); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDeleteTodoUseCase_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockDeleteTodoUseCase_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockDeleteTodoUseCase_Expecter) Execute(ctx interface{}, req interface{}) *MockDeleteTodoUseCase_Execute_Call {
	return &MockDeleteTodoUseCase_Execute_Call{Call: _e.mock.On("Execute", ctx, req)}
}

func (_c *MockDeleteTodoUseCase_Execute_Call) Run(run func(ctx context.Context, req todoapp.DeleteTodoRequest)) *MockDeleteTodoUseCase_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(todoapp.DeleteTodoRequest))
	})
	return _c
}

func (_c *MockDeleteTodoUseCase_Execute_Call) Return(err error) *MockDeleteTodoUseCase_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeleteTodoUseCase_Execute_Call) RunAndReturn(run func(ctx context.Context, req todoapp.DeleteTodoRequest) error) *MockDeleteTodoUseCase_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGetTodoUseCase creates a new instance of MockGetTodoUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetTodoUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetTodoUseCase {
	mock := &MockGetTodoUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetTodoUseCase is an autogenerated mock type for the GetTodoUseCase type
type MockGetTodoUseCase struct {
	mock.Mock
}

type MockGetTodoUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetTodoUseCase) EXPECT() *MockGetTodoUseCase_Expecter {
	return &MockGetTodoUseCase_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetTodoUseCase
func (_mock *MockGetTodoUseCase) Execute(ctx context.Context, req todoapp.GetTodoRequest) (*todo.Todo, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 *todo.Todo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.GetTodoRequest) (*todo.Todo, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.GetTodoRequest) *todo.Todo); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*todo.Todo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, todoapp.GetTodoRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetTodoUseCase_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetTodoUseCase_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockGetTodoUseCase_Expecter) Execute(ctx interface{}, req interface{}) *MockGetTodoUseCase_Execute_Call {
	return &MockGetTodoUseCase_Execute_Call{Call: _e.mock.On("Execute", ctx, req)}
}

func (_c *MockGetTodoUseCase_Execute_Call) Run(run func(ctx context.Context, req todoapp.GetTodoRequest)) *MockGetTodoUseCase_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(todoapp.GetTodoRequest))
	})
	return _c
}

func (_c *MockGetTodoUseCase_Execute_Call) Return(todo1 *todo.Todo, err error) *MockGetTodoUseCase_Execute_Call {
	_c.Call.Return(todo1, err)
	return _c
}

func (_c *MockGetTodoUseCase_Execute_Call) RunAndReturn(run func(ctx context.Context, req todoapp.GetTodoRequest) (*todo.Todo, error)) *MockGetTodoUseCase_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGetTodosUseCase creates a new instance of MockGetTodosUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGetTodosUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGetTodosUseCase {
	mock := &MockGetTodosUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGetTodosUseCase is an autogenerated mock type for the GetTodosUseCase type
type MockGetTodosUseCase struct {
	mock.Mock
}

type MockGetTodosUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGetTodosUseCase) EXPECT() *MockGetTodosUseCase_Expecter {
	return &MockGetTodosUseCase_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockGetTodosUseCase
func (_mock *MockGetTodosUseCase) Execute(ctx context.Context, req todoapp.GetTodosRequest) ([]*todo.Todo, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 []*todo.Todo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.GetTodosRequest) ([]*todo.Todo, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.GetTodosRequest) []*todo.Todo); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*todo.Todo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, todoapp.GetTodosRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGetTodosUseCase_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockGetTodosUseCase_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockGetTodosUseCase_Expecter) Execute(ctx interface{}, req interface{}) *MockGetTodosUseCase_Execute_Call {
	return &MockGetTodosUseCase_Execute_Call{Call: _e.mock.On("Execute", ctx, req)}
}

func (_c *MockGetTodosUseCase_Execute_Call) Run(run func(ctx context.Context, req todoapp.GetTodosRequest)) *MockGetTodosUseCase_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(todoapp.GetTodosRequest))
	})
	return _c
}

func (_c *MockGetTodosUseCase_Execute_Call) Return(todos []*todo.Todo, err error) *MockGetTodosUseCase_Execute_Call {
	_c.Call.Return(todos, err)
	return _c
}

func (_c *MockGetTodosUseCase_Execute_Call) RunAndReturn(run func(ctx context.Context, req todoapp.GetTodosRequest) ([]*todo.Todo, error)) *MockGetTodosUseCase_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStartTodoUseCase creates a new instance of MockStartTodoUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStartTodoUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStartTodoUseCase {
	mock := &MockStartTodoUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStartTodoUseCase is an autogenerated mock type for the StartTodoUseCase type
type MockStartTodoUseCase struct {
	mock.Mock
}

type MockStartTodoUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStartTodoUseCase) EXPECT() *MockStartTodoUseCase_Expecter {
	return &MockStartTodoUseCase_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockStartTodoUseCase
func (_mock *MockStartTodoUseCase) Execute(ctx context.Context, req todoapp.StartTodoRequest) error {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.StartTodoRequest) error); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStartTodoUseCase_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockStartTodoUseCase_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockStartTodoUseCase_Expecter) Execute(ctx interface{}, req interface{}) *MockStartTodoUseCase_Execute_Call {
	return &MockStartTodoUseCase_Execute_Call{Call: _e.mock.On("Execute", ctx, req)}
}

func (_c *MockStartTodoUseCase_Execute_Call) Run(run func(ctx context.Context, req todoapp.StartTodoRequest)) *MockStartTodoUseCase_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(todoapp.StartTodoRequest))
	})
	return _c
}

func (_c *MockStartTodoUseCase_Execute_Call) Return(err error) *MockStartTodoUseCase_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStartTodoUseCase_Execute_Call) RunAndReturn(run func(ctx context.Context, req todoapp.StartTodoRequest) error) *MockStartTodoUseCase_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdateTodoUseCase creates a new instance of MockUpdateTodoUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdateTodoUseCase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdateTodoUseCase {
	mock := &MockUpdateTodoUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdateTodoUseCase is an autogenerated mock type for the UpdateTodoUseCase type
type MockUpdateTodoUseCase struct {
	mock.Mock
}

type MockUpdateTodoUseCase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdateTodoUseCase) EXPECT() *MockUpdateTodoUseCase_Expecter {
	return &MockUpdateTodoUseCase_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockUpdateTodoUseCase
func (_mock *MockUpdateTodoUseCase) Execute(ctx context.Context, req todoapp.UpdateTodoRequest) error {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, todoapp.UpdateTodoRequest) error); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUpdateTodoUseCase_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUpdateTodoUseCase_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *MockUpdateTodoUseCase_Expecter) Execute(ctx interface{}, req interface{}) *MockUpdateTodoUseCase_Execute_Call {
	return &MockUpdateTodoUseCase_Execute_Call{Call: _e.mock.On("Execute", ctx, req)}
}

func (_c *MockUpdateTodoUseCase_Execute_Call) Run(run func(ctx context.Context, req todoapp.UpdateTodoRequest)) *MockUpdateTodoUseCase_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(todoapp.UpdateTodoRequest))
	})
	return _c
}

func (_c *MockUpdateTodoUseCase_Execute_Call) Return(err error) *MockUpdateTodoUseCase_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUpdateTodoUseCase_Execute_Call) RunAndReturn(run func(ctx context.Context, req todoapp.UpdateTodoRequest) error) *MockUpdateTodoUseCase_Execute_Call {
	_c.Call.Return(run)
	return _c
}
